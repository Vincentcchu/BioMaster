{
    "input": "{\"task\": {\"step_number\": 2, \"description\": \"Align the quality-controlled paired-end reads to the small reference genome using BWA-MEM. This step maps sequencing reads to the reference to generate an alignment file. The output will be a SAM file that contains the mapped reads, which will be sorted for downstream processing.\", \"input_filename\": [\"./output/001/clean_rnaseq_2.fastq.gz: cleaned RNA-Seq read 2 data\", \"./data/WGS_WES/minigenome.fa\", \"./output/001/clean_rnaseq_1.fastq.gz: cleaned RNA-Seq read 1 data\", \"./data/WGS_WES/minigenome.fa: small genome sequence consisting of ~750 genes.\", \"./data/WGS_WES/rnaseq_1.fastq.gz\", \"./data/WGS_WES/rnaseq_2.fastq.gz\"], \"output_filename\": [\"./output/001/aligned.sam: reads aligned to reference genome\"], \"tools\": \"BWA-MEM\"}, \"pre debug\": [], \"result\": \"Warning: 'conda-forge' already in 'channels' list, moving to the top\\nWarning: 'bioconda' already in 'channels' list, moving to the top\\n[bwa_index] Pack FASTA... 0.04 sec\\n[bwa_index] Construct BWT for the packed sequence...\\n[bwa_index] 1.56 seconds elapse.\\n[bwa_index] Update BWT... 0.03 sec\\n[bwa_index] Pack forward-only FASTA... 0.03 sec\\n[bwa_index] Construct SA from BWT and Occ... 0.49 sec\\n[main] Version: 0.7.19-r1273\\n[main] CMD: bwa index ./data/WGS_WES/minigenome.fa\\n[main] Real time: 2.568 sec; CPU: 2.136 sec\\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\\n[E::main_mem] fail to open file `./output/001/clean_rnaseq_1.fastq.gz'.\\n\", \"related_docs\": \"## Overview\\n\\nBWA (Burrows-Wheeler Aligner) is a widely used sequence alignment tool designed for mapping low-divergent reads to large reference genomes (e.g., human genomes). BWA includes three main algorithms:\\n\\n1. **BWA-backtrack**: Optimized for short reads up to 100 bp.\\n2. **BWA-SW**: Optimized for longer sequences (70 bp to 1 Mbps), supports long reads and split alignment.\\n3. **BWA-MEM**: The newest algorithm in the BWA suite, recommended for high-quality reads. It is both fast and accurate, with support for read lengths from 70 bp to 1 Mbps. BWA-MEM also performs well for reads between 70 and 100 bp.\\n\\nAmong these, **BWA-MEM** is widely used due to its balance of speed and accuracy, making it suitable for various downstream applications, such as whole-genome variant calling. It supports long reads, split alignment, and chimeric reads, and outputs standard SAM files that are compatible with tools like samtools and GATK.\\n\\nBefore running BWA-MEM, you must build an FM-index of the reference genome using the `bwa index` command. Once the index is created, you can align reads to the reference genome with the `bwa mem` sub-command.\\n\\n---\\n\\n## Installation\\n\\n1. **Download the BWA package**: Obtain the source code from the official repository.\\n2. **Compile and install**: Typically, you will use a C compiler (e.g., GCC). The official documentation provides detailed build instructions.\\n3. **Finalize installation**: Make sure your environment variables or system PATH are set correctly so you can call `bwa` directly.\\n\\n---\\n\\n## Quick Start\\n\\n1. **Indexing the reference genome**:\\n\\n```bash\\nbwa index reference.fa\\n```\\n\\nThis command builds the required FM-index for the reference genome `reference.fa`.\\n\\n2. **Running the alignment**:\\n\\n```bash\\nbwa mem reference.fa reads.fq > alignment.sam\\n```\\n\\nAligns the reads in `reads.fq` to the reference `reference.fa` and writes the alignment in SAM format to `alignment.sam`.\\n\\n---\\n\\n## Examples of Popular Commands\\n\\nBelow are five common BWA-MEM usage examples:\\n\\n1. **Indexing a reference genome with a custom prefix**:\\n\\n```bash\\nbwa index -p ref_index reference.fa\\n```\\n\\nGenerates an index for `reference.fa` with the prefix `ref_index`.\\n\\n2. **Single-end read alignment**:\\n\\n```bash\\nbwa mem ref_index reads.fq > aligned_reads.sam\\n```\\n\\nAligns single-end reads in `reads.fq` to the reference indexed by `ref_index` and outputs the result to `aligned_reads.sam`.\\n\\n3. **Paired-end read alignment**:\\n\\n```bash\\nbwa mem ref_index reads_1.fq reads_2.fq > aligned_pair.sam\\n```\\n\\nAligns paired-end reads in `reads_1.fq` and `reads_2.fq` and saves them to `aligned_pair.sam`.\\n\\n4. **Generating a sorted BAM file directly**:\\n\\n```bash\\nbwa mem ref_index reads.fq | samtools sort -o sorted_reads.bam\\n```\\n\\nPipes the alignment output from BWA to samtools and sorts it before writing to `sorted_reads.bam`.\\n\\n5. **Using extra options for speed or marking secondary alignments**:\\n\\n```bash\\nbwa mem -t 4 -M ref_index reads.fq > aligned_reads.sam\\n```\\n\\n- `-t 4`: Use 4 threads for faster alignment.\\n- `-M`: Mark shorter split alignments as secondary, which helps compatibility with certain downstream tools (e.g., Picard).\\n\\n---\\n\\n## Learning Objectives (Variant Calling Workflow)\\n\\n- Exploring the variant calling workflow\\n- Choosing suitable BWA parameters for your dataset\\n- Understanding alignment clean-up steps\\n\\n---\\n\\n## Variant Calling Workflow\\n\\nA typical variant calling workflow includes:\\n\\n1. Quality control (QC)\\n2. Alignment (e.g., using BWA)\\n3. Alignment clean-up (e.g., marking duplicates, sorting)\\n4. Variant calling\\n5. Variant filtering and annotation\\n\\nAfter obtaining raw sequencing data, you typically use tools like FastQC to check read quality. Next, you align the reads to a reference genome and clean up the alignments before applying variant-calling tools (e.g., GATK or samtools/bcftools) and then filter/annotate the resulting variants.\\n\\n---\\n\\n## Environment and Directory Setup\\n\\nIn a cluster environment (e.g., Harvard\\u2019s O2), the process might be as follows:\\n\\n1. **Request an interactive session** (example command):\\n\\n```bash\\nsrun --pty -p interactive -t 0-6:00 --mem 8G -c 2 --reservation=HBC bash\\n```\\n\\n2. **Create project directories**:\\n\\n```bash\\nmkdir ~/var-calling\\ncd ~/var-calling\\n\\nmkdir -p raw_data reference_data scripts logs meta results/bwa\\n```\\n\\n3. **Copy required data**:\\n\\n```bash\\ncp /n/groups/hbctraining/ngs-data-analysis-longcourse/var-calling/raw_fastq/*fq raw_data/\\ncp /n/groups/hbctraining/ngs-data-analysis-longcourse/var-calling/reference_data/chr20.fa reference_data/\\n```\\n\\nIn this tutorial, we use a subset of the Genome in a Bottle (GIAB) NA12878 data (human genome reads restricted to chromosome 20), consisting of ~4 million paired-end reads.\\n\\n---\\n\\n## QC and Alignment\\n\\n1. **Skipping QC**: Typically you would use FastQC, but for demonstration we skip that step.\\n2. **Aligner choice**: BWA is often preferred in variant calling for its high accuracy. Minimal misalignment can help avoid false positives in variant detection.\\n3. **BWA modes**:\\n   - BWA-backtrack: Up to 100-bp reads\\n   - BWA-SW: Longer reads (70 bp ~ 1 Mbps) with split alignment\\n   - BWA-MEM: Newest, recommended for most use cases, supports long reads and high accuracy\\n\\nIn most variant-calling workflows, **BWA-MEM** is used.\\n\\n---\\n\\n## Using BWA-MEM for Alignment\\n\\n### 1. Creating a BWA-MEM Index\\n\\n```bash\\ncd ~/var-calling/reference_data\\nmodule load gcc/6.2.0 bwa/0.7.8\\n\\nbwa index -p chr20 chr20.fa\\n```\\n\\n- `-p chr20`: Uses `chr20` as the prefix for all index files.\\n- `chr20.fa`: Reference genome file (only chromosome 20 here).\\n\\n### 2. Aligning Reads\\n\\n```bash\\ncd ~/var-calling\\n\\nbwa mem -M -t 2 \\\\\\n  reference_data/chr20 \\\\\\n  raw_data/na12878_1.fq raw_data/na12878_2.fq \\\\\\n  2> logs/bwa.err \\\\\\n  > results/bwa/na12878.sam\\n```\\n\\n- `-M`: Marks shorter split hits as secondary, helpful for some downstream tools.\\n- `-t 2`: Uses 2 threads.\\n- `2> logs/bwa.err`: Redirects standard error to a log file.\\n- `> results/bwa/na12878.sam`: Writes output to `na12878.sam`.\\n\\n---\\n\\n## Alignment Clean-up\\n\\nFor variant calling, marking duplicates is crucial to avoid PCR artifact errors.\\n\\n### 1. Installing/Loading Picard\\n\\n```bash\\nmodule spider picard\\nmodule load picard/2.8.0\\n```\\n\\nUsage:\\n\\n```bash\\njava -jar $PICARD/picard-2.8.0.jar [ToolName] [options]\\n```\\n\\n### 2. Sorting by Coordinate (SortSam)\\n\\nPicard\\u2019s `SortSam` tool sorts SAM/BAM files by coordinate. Key options:\\n- `INPUT`: Input file (SAM/BAM)\\n- `OUTPUT`: Output file (SAM/BAM)\\n- `SORT_ORDER`: Sort order (e.g., coordinate, queryname)\\n- `VALIDATION_STRINGENCY`: Level of validation (set to `SILENT` to avoid errors from BWA\\u2019s unmapped flags)\\n\\nExample:\\n\\n```bash\\ncd results/bwa\\n\\njava -Xmx8G -jar $PICARD/picard-2.8.0.jar SortSam \\\\\\n  INPUT=na12878.sam \\\\\\n  OUTPUT=na12878_sorted.sam \\\\\\n  SORT_ORDER=coordinate \\\\\\n  VALIDATION_STRINGENCY=SILENT\\n```\\n\\n### 3. Marking Duplicates (MarkDuplicates)\\n\\nPicard\\u2019s `MarkDuplicates` identifies and tags duplicate reads (PCR or optical) in BAM/SAM files. Key options:\\n- `INPUT`: Sorted input file\\n- `OUTPUT`: Output file\\n- `METRICS_FILE`: File to write duplication metrics\\n- `ASSUME_SORTED`: Set to true if the input is coordinate-sorted\\n- `VALIDATION_STRINGENCY`: Similar to above\\n\\nExample:\\n\\n```bash\\njava -Xmx8G -jar $PICARD/picard-2.8.0.jar MarkDuplicates \\\\\\n  INPUT=na12878_sorted.sam \\\\\\n  OUTPUT=na12878_sorted_marked.bam \\\\\\n  METRICS_FILE=metrics.txt \\\\\\n  ASSUME_SORTED=true \\\\\\n  VALIDATION_STRINGENCY=SILENT\\n```\\n\\n`-Xmx8G` ensures Java uses no more than 8 GB of memory (adjust if needed for larger data).\\n\\n### 4. Creating an Index for the BAM File\\n\\nUse samtools to index the marked BAM file for visualization or downstream steps:\\n\\n```bash\\nmodule load gcc/6.2.0 samtools/1.9\\n\\nsamtools index na12878_sorted_marked.bam\\n```\\n\\n---\\n\\n## Summary\\n\\nFollowing these steps, you have:\\n1. Used **BWA-MEM** to align reads to a reference genome\\n2. Sorted the alignment results\\n3. Marked duplicates\\n4. Created an index for the final BAM file\\n\\nThe resulting file can now be used in subsequent variant-calling pipelines (e.g., GATK or bcftools), followed by variant filtering and annotation. These materials are adapted from open-access teaching materials by the Harvard Chan Bioinformatics Core (HBC).\\n\\n## FASTQ to BAM/CRAM\\nModern sequencing instruments typically produce *unaligned* data in FASTQ format. We can store unaligned data in BAM or CRAM to include valuable metadata (e.g., headers, auxiliary tags), but the focus here is on producing a **sorted, aligned** BAM or CRAM file.\\n\\n---\\n\\n## Two Main Approaches\\n1. **Alignment / mapping** to a known reference.\\n2. **De-novo assembly** (not covered in detail here).\\n\\n---\\n\\n## Example Workflow for Alignment\\n\\nThis pipeline takes paired FASTQ reads, aligns them to a reference using Minimap2, and produces a sorted, duplicate-marked BAM or CRAM.\\n\\n### Steps Overview\\n1. **Map / align**\\n2. **Fix mate-pair issues** (e.g., with `samtools fixmate`)\\n3. **Mark duplicates (part 1)** \\u2013 add tags needed for later duplication marking\\n4. **Sort** to positional order\\n5. **Mark duplicates (part 2)** \\u2013 final marking of duplicates\\n6. **Convert** to final file format (BAM or CRAM)\\n\\n### Step 1: Mapping\\n```bash\\nminimap2 -t 8 -a -x sr C.Elegans.fa \\\\\\n  SRR065390_1.fastq SRR065390_2.fastq -o CE.sam\\n```\\n- `-t 8`: uses 8 threads.\\n- `-a`: output in SAM.\\n- `-x sr`: sets Minimap2 presets for paired-end short reads.\\n- Output is name-collated (read pairs are together), which is needed for the next step.\\n\\n### Step 2: Fixing Mate-Pair Issues\\n```bash\\nsamtools fixmate -O bam,level=1 CE.sam fixmate.bam\\n```\\n- `samtools fixmate` checks and corrects mate information (FLAG, RNEXT, PNEXT, TLEN).\\n- `-O bam,level=1` outputs BAM with minimal compression for speed.\\n- Add `-m` if you want to populate mate CIGAR (`MC`) and mate score (`ms`) tags:\\n\\n  ```bash\\n  samtools fixmate -O bam,level=1 -m CE.sam fixmate.bam\\n  ```\\n\\n### Step 3 & 4: Sorting to Positional Order\\n```bash\\nsamtools sort -l 1 -@8 -o pos.srt.bam -T /tmp/example_prefix fixmate.bam\\n```\\n- Sort reads by genomic coordinate.\\n- `-@8`: uses 8 threads.\\n- `-l 1`: minimal compression (optional).\\n- `-T /tmp/example_prefix`: prefix for temporary sorting files.\\n\\n### Step 5: Marking Duplicates\\n```bash\\nsamtools markdup -O bam,level=1 pos.srt.bam markdup.bam\\n```\\n- Uses the MC/ms tags from the `-m` fixmate step.\\n\\n### Step 6: Converting to Final Format\\n```bash\\nsamtools view -@8 markdup.bam -o final.bam\\n```\\nor, to produce CRAM:\\n```bash\\nsamtools view -T C.Elegans.fa -@8 markdup.bam -o final.cram\\n```\\n\\n---\\n\\n## Pipelining for Efficiency\\nInstead of writing each intermediate file to disk, we can **pipe** the commands:\\n```bash\\nminimap2 -t 8 -a -x sr C.Elegans.fa SRR065390_[12].fastq | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 -T /tmp/example_prefix - | \\\\\\nsamtools markdup -@8 --reference C.Elegans.fa - final.cram\\n```\\n- `-u` or `-O bam,level=0` keeps data uncompressed in the pipeline for speed.\\n- `set -o pipefail` helps detect errors in earlier commands.\\n\\n---\\n\\n## Converting Back to FASTQ\\nIf the unmapped reads were retained, you can revert your final BAM/CRAM to FASTQ:\\n```bash\\nsamtools sort -n -@8 final.cram | \\\\\\nsamtools fastq - -1 dat_1.fq -2 dat_2.fq > /dev/null\\n```\\n- Sorting by read name (`-n`) is required before producing paired FASTQ.\\n- The original exact FASTQ order is not preserved but is generally unimportant for reanalysis.\\n\\n---\\n\\n## De-novo Assembly\\n- Assemblers produce a consensus FASTA or FASTQ rather than individual alignments.\\n- If you need per-read alignments to the newly assembled consensus, just build an index on the assembly and follow the same **Mapping** steps as above.\\n- For CRAM, ensure you have access to the same consensus reference or embed it:\\n  ```bash\\n  samtools view -O CRAM,embed_ref in.sam -o out.cram\\n  ```\\n\\n---\\n\\n## Key Takeaways\\n- **Name-collated** BAM is essential for certain steps (e.g., `fixmate`, partial duplication marking).\\n- **Coordinate-sorted** BAM is needed for final duplicate marking and most downstream analyses.\\n- **Pipelines** avoid intermediate files, are faster, and use uncompressed or minimal-compression data in memory.\\n- **CRAM** can reduce storage size but requires consistent references.\\n- Always verify each step with basic stats (`samtools flagstat`, etc.) to ensure no unexpected data loss.\\n\", \"id\": \"001\", \"shell\": [\"conda install -y bwa samtools\", \"bwa index ./data/WGS_WES/minigenome.fa\", \"bwa mem -M ./data/WGS_WES/minigenome.fa ./output/001/clean_rnaseq_1.fastq.gz ./output/001/clean_rnaseq_2.fastq.gz > ./output/001/aligned.sam\"]}"
}