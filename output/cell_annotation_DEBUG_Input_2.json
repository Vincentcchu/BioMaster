{
    "input": "{\"task\": {\"step_number\": 2, \"description\": \"Perform quality control filtering on the AnnData object based on standard criteria: include cells with mitochondrial gene percentage less than or equal to 20%, more than 500 total UMIs, and acceptable gene feature counts. This filtering removes low-quality or dead cells to ensure robust downstream analysis.\", \"input_filename\": [\"./data/cell_annotation/dataset_debug_cleaned.json\", \"./output/cell_annotation/adata_raw.h5ad: raw AnnData object containing unprocessed single-cell gene expression and metadata\", \"./output/cell_annotation/run_dim_reduction_neighbors.py\", \"./output/cell_annotation/normalize_hvg_scanpy.py\"], \"output_filename\": [\"./output/cell_annotation/adata_filtered.h5ad: quality controlled AnnData object retained high-quality cells\"], \"tools\": \"Scanpy\"}, \"pre debug\": [], \"result\": \"/cs/student/projects2/aisd/2024/shekchu/miniconda/envs/biomaster/bin/python\\n\", \"related_docs\": \"The single-cell data marker gene identification workflow includes the following steps: Step 1: Data Reading and Initialization, reading .h5ad or 10x Genomics matrix.mtx files using scanpy.read_10x_mtx or scanpy.read_h5ad to generate an AnnData object containing the raw gene expression matrix (rows=genes, columns=cells) and metadata; Step 2: Quality Control (QC), filtering low-quality cells based on mitochondrial gene percentage (\\u226420%), total UMIs (\\u2265500), and detected genes using scanpy.pp.calculate_qc_metrics, scanpy.pp.filter_cells, outputting filtered high-quality data;Step 3: Normalization and Highly Variable Gene Selection, standardizing QC-processed data via scanpy.pp.normalize_total, scanpy.pp.log1p, and scanpy.pp.highly_variable_genes to obtain a normalized expression matrix and a list of highly variable genes (HVGs); Step 4: Dimensionality Reduction and Visualization, performing PCA dimensionality reduction using scanpy.tl.pca, constructing a KNN neighborhood graph with scanpy.pp.neighbors, output an AnnData object with dimension-reduced results; Step 5: Clustering Analysis, applying Leiden algorithm via scanpy.tl.leiden and UMAP/t-SNE visualization with scanpy.tl.umap based on dimension-reduced data, outputting cell cluster labels and visualization plots (.png); Step 6: Whole-Cell Differential Expression Analysis, applying tools to compare group differences at the whole-cell level, inputting normalized expression matrices and grouping information, using Scanpy's rank_genes_groups, sc.tl.rank_genes_groups(adata, groupby='leiden', method='t-test'),Extract the differential expression results, outputting a table of differentially expressed genes (DEGs) with with colums of log2FC, p-values, and adjusted p-values, and respectively rename the columns to logFC, pvals, and adj_pvals, df.rename(columns={'pvals_adj':'adj_pvals','logfoldchanges':'logFC'}, inplace=True); Step 7: Result Filtering, filtering marker genes based on significance thresholds adj_pvals, logFC, output high-confidence marker gene lists with adj_pvals < 0.05 and logFC > 1\\n\\nSingle-cell perform clustering analysis includes the following steps: Step 1: Data Reading and Initialization, reading .h5ad or 10x Genomics matrix.mtx files using scanpy.read_10x_mtx or scanpy.read_h5ad to generate an AnnData object containing the raw gene expression matrix (rows=genes, columns=cells) and metadata; Step 2: Quality Control (QC), filtering low-quality cells based on mitochondrial gene percentage (\\u226420%), total UMIs (\\u2265500), and detected genes using scanpy.pp.calculate_qc_metrics, scanpy.pp.filter_cells, outputting filtered high-quality data;Step 3: Normalization and Highly Variable Gene Selection, standardizing QC-processed data via scanpy.pp.normalize_total, scanpy.pp.log1p, and scanpy.pp.highly_variable_genes to obtain a normalized expression matrix and a list of highly variable genes (HVGs); Step 4: Dimensionality Reduction and Visualization, performing PCA dimensionality reduction using scanpy.tl.pca, constructing a KNN neighborhood graph with scanpy.pp.neighbors, output an AnnData object with dimension-reduced results; Step 5: Clustering Analysis, applying Leiden algorithm via scanpy.tl.leiden and UMAP/t-SNE visualization with scanpy.tl.umap based on dimension-reduced data, sc.tl.leiden(adata, resolution=), sc.pl.umap(adata, color='leiden', show=False, save='cluster_plots.png'), adata.write('./output/019/adata_clustered.h5ad'), outputting cell cluster labels and visualization plots (.png);\", \"id\": \"cell_annotation\", \"shell\": \"\"}"
}